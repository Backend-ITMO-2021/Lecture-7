# Lecture 7

## Scala FP

### Дедлайн 08/05/21 00:01 - 45 + 5 баллов
### Дедлайн 15/05/21 00:01 - 45 баллов
### Дедлайн 22/05/21 00:01 - 45 - 20 баллов

Задание выполняется на Scala в соответствии с изученным на лекции.

## 1 - Натуральные числа (5)

Тип данных натуральных чисел задан как

```scala
sealed trait Nat

case object Z

case class Succ(s: Nat)
```

Реализуйте для натуральных чисел следующие объекты:

1) `Num[Nat]` - операции сложения, умножения и вычитания
2) `Eq[Nat]` - операция сравнения

## 2 - Двоичное дерево (5)

Тип данных дерева состоит из двух частей:

1) Лист дерева, не содержит данных
2) Узел дерева. Содержит _непустой_ список одинаковых значений и имеет двух детей.

_Двоичное дерево_ называется _двоичным деревом поиска_ если оно удовлетворяет следующему условию:
значения всех элементов в левом поддереве меньше значения в узле, а значения элементов в правом поддереве больше
значения в узле.

Рекомендуется использовать `NonEmpty`.

Реализуйте следующие операции с _двоичным деревом поиска_:

1) Проверка на пустоту
2) Поиск заданного элемента в дереве (используйте тот факт, что дерево является деревом поиска)
3) Вставка нового элемента в _двоичное дерево поиска_. Если вставляемый элемент уже находится в дереве, то необходимо
   добавить его в список того узла, в котором этот элемент находится. Тут следует обратить внимание, что если в узле
   дерева есть список элементов, то этот список всегда непустой.
4) Удаление заданного элемента из дерева
5) Конвертирование списка чисел в дерево

## 3 - Foldable[Tree] (5)

Реализуйте `Foldable` для `Tree`, таким образом, чтобы запись

```scala
foldable.toList(fromList(list)) == list.sorted
``` 

была верной. Для реализации разрешается использовать все методы списков и `Foldable[NonEmpty]`.

Требуется реализовать `foldr` и `foldMap` руками (не используя в описании одного другой).

## 4 - NonEmpty (10)

Реализуйте `Functor`, `Applicative`, `Monad` для `NonEmpty`. Для реализации разрешается использовать все методы списков.

## 5 - Парсер строки (20)

Дан тип парсера строки

```scala
case class Parser[A](runParser: String => Option[(A, String)])
```

Функция `runParser` запускается для входной строки и "поглощает" буквы, т.е. если парсер считывает (поглощает) одну
букву из строки `"123"`, то его функция вернёт `Some("1", "23")`. Парсер может "падать" на входе, возвращая при
это `None`.

1) Реализуйте для него `Functor`, `Applicative`, `Alternative`, `Monad`
2) Реализуйте следующие парсеры-комбинаторы:
    1) `ok` - парсер никогда не падает, и не поглощает вход
    2) `eof` - проверяет, что парсер дошёл до конца строки, иначе падает
    3) `satisfy` - принимает предикат на букву, и возвращает эту букву, убирая её из строки, если предикат на букве
       равен `True`, иначе падает.
    4) `element` и `stream` - парсят одну или несколько букв
3) Используя реализованные парсеры-комбинаторы (добавляя недостающее по необходимости) реализуйте парсеры для:
    1) Парсер правильных скобочных последовательностей (падает, если последовательность неправильная, не падает, если
       правильная)
    2) Парсер целого числа, перед которым может быть знак `+` или `-`

При выполнении 3 пункта необходимо использовать абстракции из первой части задания.

Полезные ссылки и информация для 5:

* [Parser Combinators: Basics](https://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf)
* Alternative - имеет единственный метод `orElse`, который позволяет соединить две коробки. Например, в случае `Option`,
  если одна из коробок пустая, вернётся вторая. See `AlternativeExample`. С парсером `Alternative` работает так же -
  сначала пробует первый, потом, если не вышло - второй.

